declare const SolidityListener_base: any;
export default class SolidityListener extends SolidityListener_base {
    [x: string]: any;
    enterSourceUnit(ctx: any): void;
    exitSourceUnit(ctx: any): void;
    enterPragmaDirective(ctx: any): void;
    exitPragmaDirective(ctx: any): void;
    enterPragmaName(ctx: any): void;
    exitPragmaName(ctx: any): void;
    enterPragmaValue(ctx: any): void;
    exitPragmaValue(ctx: any): void;
    enterVersion(ctx: any): void;
    exitVersion(ctx: any): void;
    enterVersionOperator(ctx: any): void;
    exitVersionOperator(ctx: any): void;
    enterVersionConstraint(ctx: any): void;
    exitVersionConstraint(ctx: any): void;
    enterImportDeclaration(ctx: any): void;
    exitImportDeclaration(ctx: any): void;
    enterImportDirective(ctx: any): void;
    exitImportDirective(ctx: any): void;
    enterContractDefinition(ctx: any): void;
    exitContractDefinition(ctx: any): void;
    enterInheritanceSpecifier(ctx: any): void;
    exitInheritanceSpecifier(ctx: any): void;
    enterContractPart(ctx: any): void;
    exitContractPart(ctx: any): void;
    enterStateVariableDeclaration(ctx: any): void;
    exitStateVariableDeclaration(ctx: any): void;
    enterFileLevelConstant(ctx: any): void;
    exitFileLevelConstant(ctx: any): void;
    enterUsingForDeclaration(ctx: any): void;
    exitUsingForDeclaration(ctx: any): void;
    enterStructDefinition(ctx: any): void;
    exitStructDefinition(ctx: any): void;
    enterModifierDefinition(ctx: any): void;
    exitModifierDefinition(ctx: any): void;
    enterModifierInvocation(ctx: any): void;
    exitModifierInvocation(ctx: any): void;
    enterFunctionDefinition(ctx: any): void;
    exitFunctionDefinition(ctx: any): void;
    enterFunctionDescriptor(ctx: any): void;
    exitFunctionDescriptor(ctx: any): void;
    enterReturnParameters(ctx: any): void;
    exitReturnParameters(ctx: any): void;
    enterModifierList(ctx: any): void;
    exitModifierList(ctx: any): void;
    enterEventDefinition(ctx: any): void;
    exitEventDefinition(ctx: any): void;
    enterEnumValue(ctx: any): void;
    exitEnumValue(ctx: any): void;
    enterEnumDefinition(ctx: any): void;
    exitEnumDefinition(ctx: any): void;
    enterParameterList(ctx: any): void;
    exitParameterList(ctx: any): void;
    enterParameter(ctx: any): void;
    exitParameter(ctx: any): void;
    enterEventParameterList(ctx: any): void;
    exitEventParameterList(ctx: any): void;
    enterEventParameter(ctx: any): void;
    exitEventParameter(ctx: any): void;
    enterFunctionTypeParameterList(ctx: any): void;
    exitFunctionTypeParameterList(ctx: any): void;
    enterFunctionTypeParameter(ctx: any): void;
    exitFunctionTypeParameter(ctx: any): void;
    enterVariableDeclaration(ctx: any): void;
    exitVariableDeclaration(ctx: any): void;
    enterTypeName(ctx: any): void;
    exitTypeName(ctx: any): void;
    enterUserDefinedTypeName(ctx: any): void;
    exitUserDefinedTypeName(ctx: any): void;
    enterMappingKey(ctx: any): void;
    exitMappingKey(ctx: any): void;
    enterMapping(ctx: any): void;
    exitMapping(ctx: any): void;
    enterFunctionTypeName(ctx: any): void;
    exitFunctionTypeName(ctx: any): void;
    enterStorageLocation(ctx: any): void;
    exitStorageLocation(ctx: any): void;
    enterStateMutability(ctx: any): void;
    exitStateMutability(ctx: any): void;
    enterBlock(ctx: any): void;
    exitBlock(ctx: any): void;
    enterStatement(ctx: any): void;
    exitStatement(ctx: any): void;
    enterExpressionStatement(ctx: any): void;
    exitExpressionStatement(ctx: any): void;
    enterIfStatement(ctx: any): void;
    exitIfStatement(ctx: any): void;
    enterTryStatement(ctx: any): void;
    exitTryStatement(ctx: any): void;
    enterCatchClause(ctx: any): void;
    exitCatchClause(ctx: any): void;
    enterWhileStatement(ctx: any): void;
    exitWhileStatement(ctx: any): void;
    enterSimpleStatement(ctx: any): void;
    exitSimpleStatement(ctx: any): void;
    enterUncheckedStatement(ctx: any): void;
    exitUncheckedStatement(ctx: any): void;
    enterForStatement(ctx: any): void;
    exitForStatement(ctx: any): void;
    enterInlineAssemblyStatement(ctx: any): void;
    exitInlineAssemblyStatement(ctx: any): void;
    enterDoWhileStatement(ctx: any): void;
    exitDoWhileStatement(ctx: any): void;
    enterContinueStatement(ctx: any): void;
    exitContinueStatement(ctx: any): void;
    enterBreakStatement(ctx: any): void;
    exitBreakStatement(ctx: any): void;
    enterReturnStatement(ctx: any): void;
    exitReturnStatement(ctx: any): void;
    enterThrowStatement(ctx: any): void;
    exitThrowStatement(ctx: any): void;
    enterEmitStatement(ctx: any): void;
    exitEmitStatement(ctx: any): void;
    enterVariableDeclarationStatement(ctx: any): void;
    exitVariableDeclarationStatement(ctx: any): void;
    enterVariableDeclarationList(ctx: any): void;
    exitVariableDeclarationList(ctx: any): void;
    enterIdentifierList(ctx: any): void;
    exitIdentifierList(ctx: any): void;
    enterElementaryTypeName(ctx: any): void;
    exitElementaryTypeName(ctx: any): void;
    enterExpression(ctx: any): void;
    exitExpression(ctx: any): void;
    enterPrimaryExpression(ctx: any): void;
    exitPrimaryExpression(ctx: any): void;
    enterExpressionList(ctx: any): void;
    exitExpressionList(ctx: any): void;
    enterNameValueList(ctx: any): void;
    exitNameValueList(ctx: any): void;
    enterNameValue(ctx: any): void;
    exitNameValue(ctx: any): void;
    enterFunctionCallArguments(ctx: any): void;
    exitFunctionCallArguments(ctx: any): void;
    enterFunctionCall(ctx: any): void;
    exitFunctionCall(ctx: any): void;
    enterAssemblyBlock(ctx: any): void;
    exitAssemblyBlock(ctx: any): void;
    enterAssemblyItem(ctx: any): void;
    exitAssemblyItem(ctx: any): void;
    enterAssemblyExpression(ctx: any): void;
    exitAssemblyExpression(ctx: any): void;
    enterAssemblyMember(ctx: any): void;
    exitAssemblyMember(ctx: any): void;
    enterAssemblyCall(ctx: any): void;
    exitAssemblyCall(ctx: any): void;
    enterAssemblyLocalDefinition(ctx: any): void;
    exitAssemblyLocalDefinition(ctx: any): void;
    enterAssemblyAssignment(ctx: any): void;
    exitAssemblyAssignment(ctx: any): void;
    enterAssemblyIdentifierOrList(ctx: any): void;
    exitAssemblyIdentifierOrList(ctx: any): void;
    enterAssemblyIdentifierList(ctx: any): void;
    exitAssemblyIdentifierList(ctx: any): void;
    enterAssemblyStackAssignment(ctx: any): void;
    exitAssemblyStackAssignment(ctx: any): void;
    enterLabelDefinition(ctx: any): void;
    exitLabelDefinition(ctx: any): void;
    enterAssemblySwitch(ctx: any): void;
    exitAssemblySwitch(ctx: any): void;
    enterAssemblyCase(ctx: any): void;
    exitAssemblyCase(ctx: any): void;
    enterAssemblyFunctionDefinition(ctx: any): void;
    exitAssemblyFunctionDefinition(ctx: any): void;
    enterAssemblyFunctionReturns(ctx: any): void;
    exitAssemblyFunctionReturns(ctx: any): void;
    enterAssemblyFor(ctx: any): void;
    exitAssemblyFor(ctx: any): void;
    enterAssemblyIf(ctx: any): void;
    exitAssemblyIf(ctx: any): void;
    enterAssemblyLiteral(ctx: any): void;
    exitAssemblyLiteral(ctx: any): void;
    enterSubAssembly(ctx: any): void;
    exitSubAssembly(ctx: any): void;
    enterTupleExpression(ctx: any): void;
    exitTupleExpression(ctx: any): void;
    enterTypeNameExpression(ctx: any): void;
    exitTypeNameExpression(ctx: any): void;
    enterNumberLiteral(ctx: any): void;
    exitNumberLiteral(ctx: any): void;
    enterIdentifier(ctx: any): void;
    exitIdentifier(ctx: any): void;
    enterHexLiteral(ctx: any): void;
    exitHexLiteral(ctx: any): void;
    enterOverrideSpecifier(ctx: any): void;
    exitOverrideSpecifier(ctx: any): void;
    enterStringLiteral(ctx: any): void;
    exitStringLiteral(ctx: any): void;
}
export {};
